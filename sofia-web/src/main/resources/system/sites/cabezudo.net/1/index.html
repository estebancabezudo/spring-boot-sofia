<!DOCTYPE html>
<html>

<head>
  <meta content="text/html;charset=UTF-8" http-equiv="Content-Type"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title id="htmlPageTitle"></title>
  <link lib="core:1.00"/>
  <link lib="twoLanguageFlag:1.00"/>
  
</meta>



<body>
  <section id="application">
    <div id="pageContainer">
      <div id="twoLanguageFlag"></div>
      <div id="messageContainer">
        <div id="textContainer">
          <div id="nameContainer">
            <div class="line">
              <div></div>
            </div>
            <div id="name"></div>
            <div class="line">
              <div></div>
            </div>
          </div>
          <div id="ocupation"></div>
        </div>
      </div>
    </div>
  </section>
</body>


<style>/* CSS import from /index.css called by sofia */
@import url('https://fonts.googleapis.com/css?family=Montserrat&display=swap');

/* CSS import from /index.html called by style tag on index.html:21:2 */

/* CSS import from /twoLanguageFlag.css called by file librarytwoLanguageFlag:1.00 on index.html */

/* CSS code from /index.css called by sofia */
/*
    Created on : May 11, 2021, 9:56:52 AM
    Author     : Esteban Cabezudo
*/


body, html {
  font-family: 'Montserrat';
  margin: 0;
  padding: 0;
}
body {
  transition: opacity .2s;
}
a {
  color: inherit;
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}
#application {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background-image: url(images/esteban.default.jpg);
  background-color: url(transparent);
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
}
#pageContainer {
  display: flex;
  flex-direction: column;
  width: 100%;
  flex-grow: 1;
  font-size: 26px;
  text-align: center;
  margin: auto;
}
#languages {
  position: fixed;
  align-self: flex-end;
  margin: 10px;
}

#messageContainer {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  color: white;
}

#textContainer {
  display: flex;
  flex-direction: column;
  margin: 0 0 0 0;
  text-shadow: 1px 1px 4px white;
  justify-content: center;
}
#nameContainer {
  display: flex;
  justify-content: center;
}
#name {
  white-space: nowrap;
}
#ocupation {
  white-space: nowrap;
  margin: 6px;
  font-size: 12px;
}
.line{
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.line > div {
  background-color: white;
  width: 40px;
  margin: 0 10px;
  height: 1px;
}

@media all and ( min-width: 450px ) {
  #application {
    background-image: url(images/esteban.default.jpg);
  }
  #pageContainer {
    width: 60%;
  }
  #textContainer {
    margin: 0 0 0 0;
  }
}

@media all and ( min-width: 750px ) {
  #application {
    background-image: url(images/esteban.default.jpg);
  }
  #textContainer {
    margin: 0 0 0 0;
  }
}

@media all and ( min-width: 1024px ) {
  #application {
    background-image: url(images/esteban.jpg);
  }
  #textContainer {
    margin: 0 0 0 600px ;
  }
}

/* CSS code from /index.html called by style tag on index.html:21:2 */

  .twoLanguageFlagFlag {
    margin: 20px;
  }

  .twoLanguageFlagContainer {
    align-self: end;
  }

/* CSS code from /twoLanguageFlag.css called by file librarytwoLanguageFlag:1.00 on index.html */
.twoLanguageFlagContainer {
    margin: 0 0 0 10px;
    cursor: pointer;
}

.twoLanguageFlagFlag {
    width: 16px;
    height: 11px;
    display: none;
}

.twoLanguageFlagVisible {
    display: block;
}

.twoLanguageFlagContainer>.en {
    background-image: url(/images/flags/en.png);
}

.twoLanguageFlagContainer>.es {
    background-image: url(/images/flags/es.png);
}

</style>
<script>const siteLanguages = ['en', 'es'];

const templateVariables = { "site": { "name": "Sitio personal" }, "theme": { "fonts": { "serif": { "name": "Lora" }, "sansSerif": { "name": "Ubuntu" } }, "colors": { "main": "", "borders": { "normal": "#e1ebf7", "highlight": "#a7c5eb" } } }, "content": { "background": { "image": { "default": "images/esteban.default.jpg", "450": "images/esteban.default.jpg", "750": "images/esteban.default.jpg", "1024": "images/esteban.jpg" }, "color": "transparent" }, "text": { "margin": { "default": "0 0 0 0", "450": "0 0 0 0", "750": "0 0 0 0", "1024": "0 0 0 600px " } } } };
// Code from library core:1.00 on index.html
// core:setTexts
// core:webClientDataChange
// core:showMessage
// core:showErrorMessage

'use strict';

class User {
    constructor(data) {
        this.username = data.username;
        console.log(`Core::User: data.groups:`, data.groups, Core.isArray(data.groups));
        if (Core.isArray(data.groups)) {
            this.groups = data.groups;
        } else {
            this.groups = [];
            console.log(`Groups not found in user data.`, data);
        }

    };
}

const Core = {
    PLACEHOLDER: 1,
    VALUE: 2,
    texts: {},
    actualLanguage: null,
    user: null,
    requestId: 0,
    topics: [],
    reportSystemErrorFunction: null,

    queryParameters: new URLSearchParams(location.search),

    getActualWebClientDetails: () => {
        console.log(`core::getActualWebClientDetails`);
        fetch('/v1/web/clients/actual/details', {
            method: 'GET'
        })
            .then(response => response.json())
            .then(jsonData => {
                const user = jsonData.user;
                if (user === undefined || user === null) {
                    Core.user = null;
                } else {
                    Core.user = new User(user);
                }

                console.log(`commons.js::getActualWebClientDetails: `, jsonData);
                Core.publish('core:webClientDataChange', jsonData);
            });
    },

    getPreferredLanguage: () => {
        const defaultFromSiteLanguages = () => {
            if (siteLanguages.includes("en") || siteLanguages.length == 0) {
                return 'en';
            }
            return siteLanguages[0];
        };

        const browserLocale = window.navigator.userLanguage || window.navigator.language;
        if (siteLanguages.includes(browserLocale)) {
            return browserLocale;
        }
        if (siteLanguages.includes(browserLocale.substring(0, 2))) {
            return browserLocale;
        }
        if (browserLocale.length < 2) {
            return defaultFromSiteLanguages();
        }
        const browserLanguage = browserLocale.substring(1, 2).toLowerCase();
        if (siteLanguages.includes(browserLanguage)) {
            return browserLanguage;
        }
        return defaultFromSiteLanguages();
    },

    getGeoLocation: async () => {
        if (navigator.geolocation) {
            try {
                const getCurrentPositionPromiseFunction = (resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject);
                };
                const locationData = await new Promise(getCurrentPositionPromiseFunction);
                return {
                    status: "OK",
                    message: "OK",
                    code: 0,
                    data: locationData
                };
            } catch (error) {
                return {
                    status: "ERROR",
                    message: error.message,
                    code: error.code,
                    data: null
                };
            }
        } else {
            console.log("*** get end without support");
            return {
                status: "NOT_SUPPORTED",
                message: "Geolocation is not supported by this browser.",
                code: 0,
                data: null
            }
                ;
        }
    },
    getCookie: name => {
        const stringToFind = `${name}=`;
        const uriDecoded = decodeURIComponent(document.cookie);
        const cookieArray = uriDecoded.split(';');
        cookieArray.forEach(cookie => {
            while (cookie.charAt(0) == ' ') {
                cookie = cookie.substring(1);
            }
            if (cookie.indexOf(stringToFind) === 0) {
                return cookie.substring(stringToFind.length);
            }
        })
    },
    getNextRequestId: () => {
        return Core.requestId++;
    },

    getText: (key, values) => {
        if (!key) {
            console.trace();
            throw new Error(`Missing parameter key: ${key}`);
        }
        let text = texts[key];
        if (!text) {
            console.log(`No text for key: ${key}`);
            text = `[${key}]`;
        }
        if (values) {
            if (Core.isArray(values)) {
                let i = 0;
                values.forEach(value => {
                    const RegExpText = "\\{" + i + "\\}";
                    const searchRegExp = new RegExp(RegExpText, 'g');
                    text = text.replace(searchRegExp, value);
                    i++;
                });
            } else {
                throw new Error('The second parameter MUST be an array');
            }
        }
        return text;
    },

    getTimezoneOffset: () => {
        return (new Date()).getTimezoneOffset();
    },

    isArray: v => {
        return Object.prototype.toString.call(v) === '[object Array]';
    },

    isFunction: v => {
        return Object.prototype.toString.call(v) === '[object Function]';
    },

    isLogged: () => {
        const user = Core.user;
        if (user === undefined || user === null) {
            return false;
        }
        const username = user.username;
        return username !== undefined && username !== null;
    },
    isNotLogged: () => {
        return !Core.isLogged();
    },
    isString: v => {
        return Object.prototype.toString.call(v) === '[object String]';
    },

    isHTMLDivElement: v => {
        try {
            return v instanceof HTMLElement;
        } catch (e) {
            return Object.prototype.toString.call(v) === '[object HTMLDivElement]';
        }
    },

    isValid: list => {
        if (!list || list === null) {
            return false;
        }
        for (let i = 0; i < list.length; i++) {
            const value = list[i];
            console.log(`Core::isValid: Value to check: ${value}`);
            if (value === 'status:logged' && Core.isLogged()) {
                console.log(`Core::isValid: The user is logged`);
                return true;
            }
            if (value === 'status:notLogged' && Core.isNotLogged()) {
                console.log(`Core::isValid: The user is not logged`);
                return true;
            }
            if (value.startsWith("page:")) {
                const page = value.substr(5);
                if (page.endsWith('**')) {
                    console.log(`${window.location.pathname} start with ${page.substring(0, page.length - 2)}: ${window.location.pathname === page.substring(0, -2)}`);
                    if (window.location.pathname.startsWith(page.substring(0, page.length - 2))) {
                        console.log(`Core::isValid: The page is correct: ${page}`);
                        return true;
                    }
                } else {
                    console.log(`${window.location.pathname} === ${page}: ${window.location.pathname === page}`);
                    if (window.location.pathname === page) {
                        console.log(`Core::isValid: The page is correct: ${page}`);
                        return true;
                    }
                }
            }
            if (value.startsWith("group:")) {
                const group = value.substr(6);
                console.log(`Core::isValid: search for group: ${group}`);
                if (Core.user === null) {
                    return false;
                }
                console.log('Core::isValid: user: ', Core.user);
                const groups = Core.user.groups;
                console.log('Core::isValid: groups: ', groups);
                for (g of groups) {
                    if (group === g.name) {
                        return true;
                    }
                };
                return false;
            }
            if (value === 'default') {
                console.log(`It is true by default`);
                return true;
            }
        };
        console.log(`   false`);
        return false;
    },

    loadLanguage: languageCode => {
        let fetchLanguage;
        if (siteLanguages.includes(languageCode)) {
            fetchLanguage = languageCode;
        }
        if (siteLanguages.includes(languageCode.substring(0, 2))) {
            fetchLanguage = languageCode.substring(0, 2);
        }
        const page = window.location.pathname;
        if (fetchLanguage) {
            fetch(`/v1/pages/actual/texts?language=${fetchLanguage}&page=${page}`, {
                headers: {
                    "Content-Type": "application/json"
                }
            })
                .then(response => response.json())
                .then(jsonData => {
                    console.log(jsonData.data);
                    texts = JSON.parse(jsonData.data);
                    console.log(jsonData);
                    console.log(texts);
                    Core.actualLanguage = fetchLanguage;
                    Core.setTexts(texts);
                })

                ;
        } else {
            throw Error(`Invalid language: ${languageCode}`);
        }
    },

    publish: (topicsName, data) => {
        console.log(`Publish on ${topicsName}`, data);
        const functions = Core.topics[topicsName];
        if (functions && Core.isArray(functions)) {
            functions.forEach(func => {
                func(data);
            });
        }
    },
    reportSystemError: error => {
        if (Core.isFunction(Core.reportSystemErrorFunction)) {
            Core.reportSystemErrorFunction(error);
        }
    },
    setReportSystemErrorFunction: reportSystemErrorFunction => {
        Core.reportSystemErrorFunction = reportSystemErrorFunction;
    },
    // This function avoid the race condition if the asignation of the text 
    // to the element is before the text web service is called
    setText: (element, key, options) => {
        console.log(`Core::setText:`, element, key);

        Core.subscribeTo('core:setTexts', () => {
            Core.setTextToElement(element, Core.texts[key], options);
        });
        if (Core.texts[key]) {
            Core.setTextToElement(element, Core.texts[key], options);
        };
    },
    setTexts: ts => {
        texts = Object.assign(Core.texts, ts);
        Core.setTextsById();
        Core.publish('core:setTexts', { language: Core.actualLanguage });
    },
    showErrorMessage: errorMessage => {
        let jsonMessage;
        if (Core.isString(errorMessage)) {
            jsonMessage = { errorMessage };
        } else {
            jsonMessage = errorMessage;
        }
        console.log(`Core::showErrorMessage:`, jsonMessage);
        Core.publish('core:showErrorMessage', jsonMessage);
    },
    showMessage: message => {
        let jsonMessage;
        if (Core.isString(message)) {
            jsonMessage = { message };
        } else {
            jsonMessage = errorMessage;
        }
        console.log(`Core::showMessage: ${jsonMessage}`, jsonMessage);
        Core.publish('core:showMessage', jsonMessage);
    },
    setTextsById: () => {
        console.log(`Core::setTextsById: Set text by id`);
        for (const [key, value] of Object.entries(Core.texts)) {
            const element = document.getElementById(key);
            Core.setTextToElement(element, value);
        }
    },
    setTextToElement: (element, text, options) => {
        if (Core.isHTMLDivElement(element)) {
            console.log(`Core::setTextToElement: Trying to set text to ${element.id} (${element.constructor.name})`);
            do {
                if (
                        element instanceof HTMLSpanElement || element instanceof HTMLDivElement || element instanceof HTMLButtonElement || element instanceof HTMLOptionElement || element instanceof HTMLAnchorElement ||
                        element instanceof HTMLTitleElement || element instanceof HTMLParagraphElement || element instanceof HTMLHeadingElement) {
                    console.log(`Core::setTextToElement: Set text ${text} to element with id ${element.id}`);
                    const childNodes = element.childNodes;
                    const write = childNodes.length === 0 || (childNodes.length === 1 && childNodes[0].nodeType === Node.TEXT_NODE && element.textContent !== text);
                    if (write) {
                        element.innerHTML = text;
                    } else {
                        console.log(`Core::setTextToElement: WARNING. The element with the id ${element.id} is not empty.`, element);
                    }
                    break;
                }
                if (element instanceof HTMLInputElement) {
                    console.log(`Core::setTextToElement: element type: ${element.type}`);
                    switch (element.type) {
                        case 'submit':
                            element.value = text;
                            break;
                        case 'text':
                            if (options === undefined || options === null || options & Core.PLACEHOLDER === Core.PLACEHOLDER) {
                                element.placeholder = text;
                            }
                            if ((options & Core.VALUE) === Core.VALUE) {
                                element.value = text;
                            }
                            break;
                        case 'password':
                            element.placeholder = text;
                            break;
                        default:
                            console.log(`Core::setTextsById: WARNING. Can't manage the type for the input element ${key}.`, element);
                    }
                    break;
                }
                throw Error(`Set text to unknown element with id ${element.id} (${element.constructor.name})`);
            } while (false);
        }
    },

    subscribeTo: (topicsName, functionToExecute) => {
        let functions = Core.topics[topicsName];
        if (!functions) {
            functions = [];
            Core.topics[topicsName] = functions;
        }
        functions.push(functionToExecute);
    }
}

const pageLoaded = async () => {
    console.log(`Core::pageLoaded::templateVariables: `, templateVariables);
    Core.getActualWebClientDetails();
    Core.subscribeTo('core:webClientDataChange', data => {
        console.log('Data from core:webClientDataChange topic: ', data);
        if (data.language === undefined || data.language === null) {
            Core.loadLanguage(Core.getPreferredLanguage());
        } else {
            Core.loadLanguage(data.language);
        }
    })
}

window.addEventListener('load', pageLoaded, false);

// Code from library twoLanguageFlag:1.00 on index.html
/*
 * Created on: 11/05/2021
 * Author:     Esteban Cabezudo
 */

class TwoLanguageFlag {
    constructor(configuration) {
        this.languages = configuration.languages;
        this.onchange = configuration.onchange;
        const validateOptions = () => {
            this.container = document.getElementById(configuration.id);
            if (!this.container) {
                throw new Error(`Can't find the element with the id ${configuration.id}`);
            }
        }
        const setFlagToShow = () => {
            if (Core.actualLanguage === this.languages[0].code) {
                this.languages[1].element.classList.add('twoLanguageFlagVisible');
                this.languages[0].element.classList.remove('twoLanguageFlagVisible');
            } else {
                this.languages[0].element.classList.add('twoLanguageFlagVisible');
                this.languages[1].element.classList.remove('twoLanguageFlagVisible');
            }
        };
        const createGUI = () => {
            this.container.className = 'twoLanguageFlagContainer';
            const setLanguageFlag = (languageToSet) => {
                languageToSet.element.className = 'twoLanguageFlagFlag';
                languageToSet.element.classList.add(languageToSet.code);
                languageToSet.element.addEventListener('click', event => {
                    Core.loadLanguage(languageToSet.code);
                    if (Core.isFunction(this.onchange)) {
                        this.onchange(languageToSet.code);
                    }
                    event.stopPropagation();
                });
                this.container.appendChild(languageToSet.element);
            }
            this.languages[0].element = document.createElement('DIV');
            this.languages[1].element = document.createElement('DIV');
            setLanguageFlag(this.languages[0]);
            setLanguageFlag(this.languages[1]);
            Core.subscribeTo('core:setTexts', setFlagToShow);
        };
        validateOptions();
        createGUI();
    };
    getActualLanguage = () => {
        return Core.actualLanguage;
    };
}

// Code from script tag on index.html:10:4

    const initPage = () => {
      new TwoLanguageFlag({
        id: 'twoLanguageFlag',
        languages: [{ code: 'en' }, { code: 'es' }]
      });
    };
    window.addEventListener('load', initPage);
  

</script>
</head>
</html>